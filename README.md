# algorithm-js
常用的js算法

#### 3-1 求二叉搜索树的第K小值-二叉树和三种遍历
binary-search-tree-base  
 
#### 3-2 求二叉搜索树的第K小值-解题  
二叉搜索树特点：  
left value <= root value  
left value >= root value  
二叉搜索树的价值：方便使用二分法快速查找  
思路：先中序遍历,在找k值
#### 3-3 为什么二叉树很重要，而不是三叉树四岔树
性能：  
数组：查找快O(1),增删慢O(n)  
链表：查找慢O(n),增删快O(1)  
二叉搜索树BST：查找快，增删快 --“木桶效应”  

平衡二叉树：
BST如果不平衡慢，就成了链表了  
要尽量平衡：平衡二叉搜索树BBST  
BBST增删查，时间复杂度都是O(logn),即树的高度  

扩展：  
红黑树、B树都是二叉树的变种，目的都是让整体效果最优，满足不同场景  

#### 3-4 堆有什么特点，和二叉树有什么关系
堆栈模型：js代码执行时，值类型变量，存储在栈；引用类型变量，存储在堆  
堆：逻辑上是一棵二叉树；物理上是一个数组 

#### 3-5 求斐波那契数列的第n值-递归算法会导致运行崩溃
0 1 1 2 3 5 8 13 21 34 ...  
f(0)=0  
f(1)=1  
f(n) = f(n-1) + f(n-2)    
fibonacci.ts - fibonacci2  

#### 3-6 求斐波那契数列的第n值-优化时间复杂度-part1
fibonacci.ts - fibonacci  
总结：  
动态规划：把一个大问题，拆解为多个小问题，逐级向下拆解；用递归的思路去分析问题，再改为循环来实现
算法三大思维：动态规划（这个例子）、贪心、二分

#### 3-7【连环问】青蛙跳台阶有几种方式
一只青蛙，一次可跳1级，也可跳2级  
问：青蛙跳到n级台阶，总共有多少种方式  
n=1 f(n)=1  
n=2 f(n)=2  
...  
fn = f(n-1) + f(n-2)  

#### 3-8 移动0到数组的末尾-splice会导致性能问题  
如果不限制“必须在原数组操作”：  
定义part1 part2两个数组；遍历数组，非0push到part1，0push到part2；返回part1.concat(part2)  

限制在原数组操作：  
传统思路：  
遍历数组，遇到0则push到数组末尾；用splice截取掉当前元素；时间复杂度是O(n^2)-不可用  
move-zero.ts  

优化思路：  双指针  
定义j指向第一个0，i指向j后面的第一个非0；交换i和j的值，继续向后移动；只遍历一次，所以时间复杂度是O(n)


#### 3-9 移动0到数组的末尾-使用双指针


#### 3-10 获取字符串中连续最多的字符以及次数-使用嵌套循环
#### 3-11 获取字符串中连续最多的字符以及次数-使用双指针
#### 3-12 获取字符串中连续最多的字符以及次数-正则表达式很慢
#### 3-13 用JS实现快速排序并说明时间复杂度-代码演示和单元测试 
#### 3-14 用JS实现快速排序并说明时间复杂度-性能分析
#### 3-15 获取1-10000之前所有的对称数（回文数）-代码演示
#### 3-16 获取1-10000之前所有的对称数（回文数）-性能分析
#### 3-17 如何实现高效的英文单词前缀匹配
#### 3-18 用JS实现数字千分位格式化
#### 3-19 用JS切换字母大小写
#### 3-20 为什么0.1+0.2!==0.3


### 单元测试 jest
npx jest dist/binary-search-tree.test.js